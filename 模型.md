# 模型

模型是Bamboo框架的核心，是对数据库中数据组织关系的抽像。


## 模型长什么样
模型就长下面这个样子。

  local Model = require 'bamboo.model'

  local Mymodel = Model:extend {
    __name = 'Mymodel';
    __fields = {
      ['name'] = {},	
    
    };
    
    init = function (self, t)
      
      return self
    end;
    
  }

  return Mymodel

可以按自己的要求基于这个生成的文件作修改。下面讲解一下这个文件的结构。

- 首先，模型文件实际上也是用lua的module机制来实现的，跟模块的写法一模一样；
- 第二步，引入模型定义必要的依赖及父模型，Bamboo中基础的模型就是`Model`；
- 第三步，利用oop语法，从父模型继承，生成一个新模型，变量取名就是我们要定义的模型名字。语法为：`local Mymodel = Model:extend { ...... }`；
- 第四步，返回此模型。即 `return Mymodel`。

说明：

- `__name`用于指明模型的存储名称。一般就与`__tag`的最后一个单词相同；
- `__fields`用于定义此模型的字段。

## 模型创建快捷方式
模型需要在单独的文件中定义。bamboo提供了一个方便的指令来创建一个新模型。执行命令 `bamboo createmodel Mymodel` 后，会在当前目录下生成一个`mymodel.lua`文件，这个文件就是模型`Mymodel`的定义文件。

## 模型如何使用

比如，我们定义好了模型`Mymodel`，放在`models/`目录下，要使用这个模型，我们需要：

1. 引入此模型文件并注册，如下：

    local Mymodel = require 'models.mymodel'
    bamboo.registerModel(Mymodel, db, redis)
    -- db可省略，默认寻找全局变量：BAMBOO_MDB
    -- redis可省略，默认寻找全局变量：BAMBOO_DB
    -- 注：注册了之后，会在模型对象里面，生成几个引用
    --   __db     mongodb的连接对象
    --   __redis  redis的连接对象
    --   __collection  本模型对应的mongodb数据库中的collection名称（字符串）

2. 使用`Mymodel(params)`的语法来生成模型实例：

    local one_instance = Mymodel(params)

3. 使用`instance_obj:save()`的方式，来保存此实例到数据库。

    instance_obj:save()

下面给出一个简单的handler作示意：

  local function handler_createMymodel(web, req)
    local params = req.POST
    local one_instance = Mymodel(params)
    one_instance:save()
    return web:redirect("/result/")
  end

## ID
每个模型的实例都有id。但由于我们的主数据库是mongodb，mongodb会自动生成id。它生成的id的字段名称是：`_id`，并且其值是一个`ObjectId`对象。因此，并不符合我们之前的使用习惯。所以BAMBOO做了一些中间工作，自动定义了另一个字段，`id`，它的值就是 `tostring(_id)` 的结果，就是一个有规律的24位长的字符串。但是这个字段值并不存储在mongo中，只存在于BAMBOO进程中。

在使用的时候，可以使用`_id`查找，也可以使用`id`查找（BAMBOO的mongo驱动内部自动作转换）。

  
## 初始化函数

`init()`是初始化函数。初始化函数用于在生成模型实例的时候，对实例按传进来的参数进行初始化。在这个函数中，有以下几点需要注意：

1. 函数参数`t`表示外面传进来的一张table，里面提供了用于实例初始化的值；
2. 此函数必须返回 `self`；
3. 初始化函数中，不应该操作外键域。

关于继承，系统会按继承关系，先执行完父类的`init()`函数，再执行子类的`init()`函数，以此类推。

## 方法继承，字段复制

在Bamboo中的模型的面向对象实现遵守方法继承，字段复制的原则。具体意思是：子模型可以使用父类的方法，同时将父类的所有字段都复制到自己的字段集中。因此，在子类的init函数中，只需初始化相较于父类新定义的字段即可（当然，也可对父类中定义的字段按自己的要求进行再次初始化，不会有问题）。默认Model已经对所有字段进行了基本的赋值操作，没有特殊的操作的话，连`init()`都可以不写。

## 字段描述表

`__fields`字段定义表中是各个字段的定义，字段定义的方式也是key-value的形式，key是字段名称，value是一张表，这张表就是**字段描述表**。如上例中的：

    __fields = {
      ['name'] = {},		-- 这个{}就是字段描述表了。
    
    };

字段描述表中，需要放置一些预定义的key-value对。目前，可写下面一些key-value（用户可以根据需要，灵活地添加自定义key-value对）。

#### foreign 	

**外键定义**。用于声明此字段是否是外键字段，不写表示非外键字段，写上表示此字段是外键字段。在内部，foreign字段存储的是外链模型实例的索引。

取值范围

    Model_name		表明此外键指向模型Model_name的实例，Model_name要换成具体的模型名称。比如：`User`； 
    UNFIXED			  非固定类型的外键。它的意思是，在不同的场合下，这个外键可以连接不同的模型。这个只是标识性的文字，在具体应用中，需要在注册模型的时候，将它翻译为具体的类型；
    ANYSTRING		  任意字符串。这些字符串不一定是某个模型的实例，而是任意字符串
    ANYOBJ        任意对象。一般是一个table，里面有id这个字段；

#### st 		

**存储类型（store type）**，用于指明外键存储的类型。如果`foreign`存在，则这个属性必须存在。

取值范围

    ONE				存一个
    MANY			存多个，非重复
    LIST			存多个，可重复
    FIFO		  存指定数目的多个。可由fifolen属性定义，默认长度为100。当数据填满的时候，会执行先进先出的操作。可重复
    ZFIFO			存指定数目的多个。可由fifolen属性定义，默认长度为100。当数据填满的时候，会执行先进先出的操作。不可重复
  


#### required	

指明此字段在数据库存储的时候是必须的, 在模型validate的时候有用；

取值范围

    true			需要的时候才有必要写出来
    false or nil（不写）
    
#### type

指明此字段具有某种类型。

取值范围

    number			表明此字段存储的是number值。声明了后，取的时候，会自动进行tonumber的转换
    boolean     表明此字段存储的是boolean值。声明了后，取的时候，会自动进行到true或false的转换

#### enum

在这里面写上此字段可能的几种取值。此key的value是一张table。

#### fifolen

当st取FIFO或ZFIFO时，此key-value用于指定此FIFO或ZFIFO的长度。

取值范围

    number  大于0
  
#### min max

用于标明此字段为数字，并且最小值不能小于min，最大值不能大于max。在模型的validate的时候有用

取值范围

    number

#### min_length  max_length

用于标明此字段的值（字符串）的最小长度不能小于`min_length`，最大长度不能大于`max_length`。在模型的validate的时候有用

取值范围

    number

#### pattern

用于标明此字段的值（字符串）必须符合给定的pattern。在模型的validate的时候有用

取值范围

    lua正则表达式


## Query Args

`get`和`filter`是模型API中两个重要的函数，用于根据给出的条件获取和过滤符合要求的实例。这些条件必须写在一个query表里面，query表类似如下形式：

    model_obj:get { foo=bar, x=lt(1000), timestamp=gt(100000) }  
    model_obj:filter { foo=bar, x=lt(1000), timestamp=gt(100000) }  

即写成：`字段名=关系函数(参数表)`的形式。关系函数详细列表见[检索关系函数](检索关系函数.md) 这一章。

get返回一个（第一个）对象实例，filter返回一个query set，即对象的一个检索列表（此列表提供一些方法方便操作）。


## 模型基础API

这里列出的所有类方法都可以供所有继承自Model的类使用，所有实例方法可供所有这些类以及类的实例使用。

##### ModelObj:getById (id, fields)   通过id获取实例对象

    通过id获取实例对象，并返回此对象  
    类方法
      
    - id			实例的id  
    - fields  可选。待取的字段描述（{field_a=true, field_b=true}）的形式

##### ModelObj:getByIds (ids, fields)   通过ids获取实例对象列表

    通过ids获取实例对象列表，并按id顺序返回此对象列表  
    类方法
      
    - ids			实例列表的ids  
    - fields  可选。待取的字段描述（{field_a=true, field_b=true}）的形式

##### ModelObj:getByIndex (index, fields)   通过index获取实例对象

    通过index获取实例对象，返回，特定对象
    类方法
      
    - index		实例在其模型表中的序号（从前往后排）  
    - fields  可选。待取的字段描述（{field_a=true, field_b=true}）的形式
    
##### ModelObj:all (fields, is_rev)   取出此模型的所有实例对象

    取此model旗下的所有实例对象，并返回此对象列表  
    类方法  
      
    - fields  可选。待取的字段描述（{field_a=true, field_b=true}）的形式
    - is_rev 	可选。是否反向标志。此值只有当为字符串'rev'时，表示反向生成结果列表；反之，省略此参数或者取其它任何值都表示正向生成结果列表  

##### ModelObj:slice (fields, start, stop, is_rev)   取出此模型的所有实例对象的一个切片

    获取此model旗下的所有实例对象的一个切片，并返回此对象列表  
    类方法
      
    - fields    可选。待取的字段描述（{field_a=true, field_b=true}）的形式
    - start  		可选。正数的话从1开始，可以为负的索引  
    - stop   		可选。不能小于start，可以为负的索引，最后一个为-1  
    - is_rev 		可选。是否反向标志。此值只有当为字符串'rev'时，表示反向结果列表；反之，省略此参数或者取其它任何值都表示不对结果列表作处理  

##### ModelObj:allIds (is_rev)   获取所有id

    获取此model旗下的所有id，并返回此id列表  
    类方法
      
    - is_rev 		可选。是否反向标志。此值只有当为字符串'rev'时，表示反向结果列表；反之，省略此参数或者取其它任何值都表示不对结果列表作处理  

##### ModelObj:sliceIds (start, stop, is_rev)    返回此模型的所有实例id组成的一个列表的一个切片

    获取此model旗下的所有id的一个切片，并返回此id列表。  
    类方法  
    
    - start	  	可选。正数的话从1开始，可以为负的索引  
    - stop   		可选。不能小于start，可以为负的索引，最后一个为-1  
    - is_rev 		可选。是否反向标志。此值只有当为字符串'rev'时，表示反向生成结果列表；反之，省略此参数或者取其它任何值都表示正向生成结果列表  

    Note:
    1. 所有参数都不加，效果与allIds一样；
    
##### ModelObj:numbers ()   取当前数据库中此模型下的真实实例个数

    获取此model旗下的实例的总数目，返回此整数  
    类方法

##### ModelObj:count (query_args)   计算此模型中满足query_args的实例的数目

    计算此模型中满足query_args的实例的数目，返回此整数  
    类方法

    query_args    与get, filter中的query_args一样的检索表达式


##### ModelObj:get (query_args, fields, skip)   取出此模型的一个实例

    按参数取出此模型的一个实例
    类方法
      
    - query_args  	query 参数表  
    - fields 		    待取的字段筛选表
    - skip          查询时，将要跳过的实例的个数

##### ModelObj:filter (query_args, fields, skip, ntr)    出此模型的实例列表

    根据参数取出此模型的一批实例。
    类方法
      
    - query_args  	query参数表  
    - fields 		    待取的字段筛选表
    - skip          查询时，将要跳过的实例的个数
    - ntr           待返回的（最多的）结果数目

##### ModelObj:validate (params)   基于字段描述表的定义对提交的数据params进行验证

    传进来的参数一条一条验证后，完全符合要求的，返回true；只要有一条验证不满足，就返回false，以及一条错误信息  
    类方法
      
    - params 		一个key-value的table，一般为从客户端传上来的参数解析（用Form:parse()等）后的结果；  

##### ModelObj:delById (id)

    根据id删除对象
    类方法
    
    - id			可以是单个id
  
##### obj:getFDT (field)

    取得模型中field字段的字段描述表
    类与实例方法
  
    注：此函数除了实例可以调用外，类对象也可以调用  
    
##### obj:getClassName ()

    取得模型的名称
    类与实例方法
  
    注：此函数除了实例可以调用外，类对象也可以调用  
 
##### obj:getClass ()

    取得模型的对象定义（从实例取得模型本身）
    实例方法
  
------------------------------

##### instance_obj:save (params)   保存本实例对象（的非外键部分）到数据库

    保存本实例对象（的非外键部分）到数据库
    实例方法
    
    - params		可选。用于更新对象内容的table表
    - 返回值		  instance_obj self
  
    Note：
    1. 这是将数据存入数据库中的最常用的方法；
    2. 仅在实例save到数据库后，才会产生一个id。save操作会将此id更新到self对象的id字段中去；
    3. 此函数无法对外键域进行操作

##### instance_obj:update (field, new_value)   更新本实例对象的某一个字段（非外键）到数据库（避免全部保存拖低效率）
    更新本实例对象的某一个字段（非外键）到数据库（避免全部保存拖低效率）
    实例方法  
    
    - field  		  要更新的字段 
    - new_value  	此域的新值，可以为字符串、数字或nil
    
    注意：
    1. 此接口无法对外键域进行操作；
    2. 当new_value为nil时，实际执行的是删除此字段的操作

##### instance_obj:del ()    删除本实例对象或本实例对象列表

    删除本实例对象或本实例对象列表
    实例方法


## 外键

`foreign`与`st`组合，（目前）可以产生`2*5=15`种应用情形（不排除更多的扩展）。

### 模型外键的完整解决方案

外键分为**一对一**，**一对多**，**多对多**三种，同时又有正向、反向两个方向。

    一对一关系，正向反向都是单个指向。
    一对多关系，正向是多个指向，反向是单个指向。
    多对多关系，正向是多个指向，反向是多个指向。 

在Bamboo的模型实现中，对上面情况的处理方式是在字段描述表里面写属性。比如，我们现在有两个模型，`model_A`和`model_B`，现在站在`model_A`的立场来看。

    一对一正向：foreign=’model_B’, st=’ONE’
    一对一反向：foreign=’model_A’, st=’ONE’
    一对多正向：foreign=’model_B’, st=’MANY’
    一对多反向：foreign=’model_A’, st=’ONE’
    多对多正向：foreign=’model_B’, st=’MANY’
    多对多反向：foreign=’model_A’, st=’MANY’ 

在字段描述表里面写明后，还得需要相应的方法来操作它们，Bamboo提供了一套完整的外键API：

### 外键API

##### instance:addForeign(field_name, obj)

  向本对象的某一个外键域`field_name`中添加新对象的索引（实际就是存储这个新对象的id值）。可以看出，要先获得obj才行；
  
    - field_name		外键域
    - obj				对象
    
    obj可取如下值
    - 对象实例；
    - 任意字符串，当foreign="ANYSTRING"的时候；
    - 任意对象table，此对象中，应该有id这个字段，不然无法使用后面的某些api

##### instance:getForeign(field_name, fields, start, stop, is_rev)

    获得本对象的field_name的外键对象。
    对于单外键的情况，返回的是那个外链对象；对于多外键的情况，返回的是那些外链对象的列表。可以用start和stop参数来决定获取多外键的某一个切片。

    - field_name		外键域
    - fields      待取的字段集
    - start				切片起始位置，支持负索引
    - stop				切片结束位置，支持负索引
    - is_rev			如果有，只能取'rev'。表明在切片后，对结果进行反向
  

##### instance:getForeignIds(field_name, start, stop, is_rev)

    获得外键的索引id，对于单外键，返回一个id值；对于多外键，返回一个id list.

    - field_name		外键域
    - start				切片起始位置，支持负索引
    - stop				切片结束位置，支持负索引
    - is_rev			如果有，只能取'rev'。表明在切片后，对结果进行反向

##### instance:removeForeignMember(field_name, obj)

    删除外键索引中的一个成员。

    - field_name		外键字段名称
    - obj				    实例对象，或实例的id


##### instance:hasForeignMember (field_name, obj)

    判断instance的外键 field_name 中是否有对象obj的索引。

    - field_name		外键字段名称
    - obj				    实例对象，或实例的id

##### instance:hasForeignKey (field_name)

    判断instance是否有外键域field_name（是否已经有值，而不是其模型中是否定义）
      
    - field_name        外键字段名称

##### instance:numForeign (field_name)

    计算instance的外键field_name中的外键索引数目

    - field_name	外键字段名称

##### instance:delForeign(field_name)

    删除此外键字段。

    - field_name		外键字段名称

##### instance:deepDelForeign(field_name)

    删除此外键字段，同时删除此外键字段中所关联的元素（不递归）。

    - field_name		外键字段名称
    
    Note:
    1. 此乃非常危险的操作。
    

### 编程提醒
在外键的定义的时候，一个完整的外键关系实际是需要正反双方共同完成，即正向反向都要定义。但正向反向都定义的话，会导致增加域。所以，很多时候，只用得到一半关系，有可能是正向的一半，也有可能是反向的一半。由于有一半关系的存在，因此，当删除一个模型的对象的时候，引用这个外键对象的另一个模型的那个对象，可能根本无法知道。于是自动化的删除管理就是一件非常困难的事情，这也是数据库系统中历来最头痛的一件事情。

鉴于这种困难，Bamboo把外键删除的工作交由用户自己来管理。用户根据自己的业务逻辑小心地处理一个对象删除后，其它相关引用对象外键去留的问题。

---------------------------------


